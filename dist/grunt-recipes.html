<!doctype html>
<html>
	<head>
		<title>Grunt Up & Running</title>
		<style type='text/css'>

		body {
			font-family: Georgia, "Times New Roman", serif;
			color: #222;
			background: #f0f0f0;
			line-height: 1.4;
		}

		h1, h2, h3, h4, h5, h6 {
			font-family: Helvetica, Arial, sans-serif;
		}

		a {
			color: #1F3C99;
			text-decoration: none;
		}

		article {
			max-width: 44em;
			margin: 0 auto;
			padding: 5em;
			background: #fff;
		}

		pre, code {
			font-family: Consolas, Monaco, monospace;
		}

		pre {
			padding: 1em 5em;
			background: #ddd;
			overflow: auto;
			color: #555;
			margin: 1em -5em;
		}

		</style>
	</head>
	<body>
		<article>
			<h1>Grunt Up &amp; Running</h1>
<p>A book by Dan Burzo (<a href="http://twitter.com/danburzo">@danburzo</a>)</p>
<h2>About this book</h2>
<p>This is a book about using Grunt to automate your web development workflow. </p>
<p>You can find it on GitHub: <a href="https://github.com/danburzo/grunt-recipes">https://github.com/danburzo/grunt-recipes</a>. Contributions/corrections are always welcome.</p>
<h2>Getting started</h2>
<h3>Meet Grunt</h3>
<p>Grunt was created by Ben Alman a.k.a. <a href="http://twitter.com/cowboy">@cowboy</a> to automate his front-end development workflow. You know, all the little repetitive tasks like unit testing, minifying your JavaScript and CSS, compiling your Sass stylesheets or CoffeeScripts, linting and what-not. With Grunt, they become a breeze: configure them once and let Grunt run them for you; in this sense, Grunt is a <em>task runner</em> for the boring but oh-so-necessary parts of the web developer&#39;s life. It&#39;s <a href="https://github.com/gruntjs/">open source</a> and at the heart of a wonderful ecosystem of thousands of plugins. As such, any tool you&#39;ve ever used in your workflow is likely to have a Grunt counterpart. And if it doesn&#39;t, it&#39;s easy to roll out your own plugin and share it with the community. Organizations like Twitter, Adobe, jQuery (and <a href="http://gruntjs.com/who-uses-grunt">many others</a>) use it and so should you, because it&#39;s A Great Thing&trade;.</p>
<h3>Front-end workflow?</h3>
<p>Here are some things we talk about when we talk about front-end workflow:</p>
<h4>Optimizing for speed: concatenation &amp; minification</h4>
<p>One of the tenets of optimizing web applications is to do everything in our power to reduce (1) the amount of HTTP requests and (2) the payload for each HTTP request. In real life, this means bundling your scripts, stylesheets &mdash; and even images! &mdash; into as few files as possible, using whatever tools one can cobble together.</p>
<p>We&#39;ll use Grunt to make our web application production-ready.</p>
<h4>Keeping things modular</h4>
<p>HTML lacks a way to compose your pages from modules. To have a website with multiple pages that share a common header and footer, which is to say any website ever, you&#39;re stuck with:</p>
<ul>
<li>repeating the same markup in each page of your site, making sure to update all pages when you want to make even the smallest change (highly impractical);</li>
<li>using frames to load multiple HTML files on a single page &mdash; one for the header, one for the footer, one for the main content (usability nightmare); </li>
<li>using PHP or equivalent language to include bits of HTML dynamically (needs a web server with PHP support);</li>
<li>loading the modules through AJAX calls (needs JavaScript to work, poor search engine ranking);</li>
</ul>
<p>We&#39;ll learn how to use Grunt to write and compose HTML modules in a straightforward way.</p>
<h4>Making CSS &amp; JavaScript fun again</h4>
<p>CSS and JavaScript are wonderful things with less-than-wonderful parts. CSS is crippled by repetition since it lacks variables and inheritance. JavaScript uses prototype inheritance, which seems un unnerve people used to classical inheritance.</p>
<p>Sass, LESS and a host of other languages superset CSS with features like variables, mixins, nesting and functions, which makes the code more concise, readable and maintainable. Through dedicated tools, these can be compiled into normal CSS and used in web pages.</p>
<p>Similarly, CoffeeScript and TypeScript aim to soothe the pains of JavaScript developers by providing traditional classes and inheritance along other features and syntactic goodies.</p>
<p>We&#39;ll see how Grunt can pre-process these files automatically, so you don&#39;t even have to think about it.</p>
<h4>Keeping bugs at bay</h4>
<p>Lint is the fluff that accumulates on your clothes or in your bellybutton, but it&#39;s also the name of a class of tools that look at your code and flag potentially flawed constructs. They&#39;re formally known as <em>static code analysis tools</em>.</p>
<p>We have lint checkers for JavaScript that remind you that <code>==</code> is not the same thing as <code>===</code> or that declaring functions inside a for-loop is generally a bad idea. They also point out style inconsistencies, such as using tabs <em>and</em> spaces for indentation (make up your mind, will you?).</p>
<p>And then there&#39;s unit testing, that thing you should be doing &mdash; in fact, I&#39;m going to assume you are &mdash; that keeps us safe from breaking things when we refactor code.</p>
<p>We&#39;ll find that Grunt is the perfect tool to automate code checking &amp; testing.</p>
<h4>Better documentation</h4>
<p>They say every person has a book in them. Grunt can help your meticulously crafted comments really shine by making them into clean, readable documentation.</p>
<h3>Resources</h3>
<p>Here are a few places we&#39;re going to visit quite often, so make sure you have them handy:</p>
<ul>
<li><a href="http://gruntjs.com">http://gruntjs.com</a>, Grunt&#39;s official page, with guides and the API reference;</li>
<li><a href="http://gruntjs.com/plugins">http://gruntjs.com/plugins</a>, the list of all available Grunt plugins &mdash; the ones that start with <code>grunt-contrib-</code> are maintained by the Grunt team, while the others are created by people like you and me;</li>
<li><a href="https://twitter.com/gruntjs">@gruntjs</a> for updates on the topic;</li>
<li>the IRC channel <code>#grunt</code> on <code>irc.freenode.net</code> is where the team members hang out.</li>
</ul>
<h3>Get Grunt Up &amp; Running</h3>
<p>Grunt is written in JavaScript, so you&#39;ll need a Node.js environment and the Node Package Manager that comes with it. </p>
<h4>Install Node</h4>
<p>Go to <a href="http://nodejs.org/download/">http://nodejs.org/download/</a> and grab the installer for your operating system. It will install Node and NPM.</p>
<p><em>Note:</em> Working with Grunt means interacting with a shell, which Mac and Linux users are lucky enough to have readily available. As for Windows, let&#39;s just say I&#39;d eat a live snail before I use the Command Prompt. Instead, I suggest you install Git for Windows &mdash; available at <a href="http://git-scm.com/downloads">http://git-scm.com/downloads</a> &mdash; that comes with a real shell and, seriously, who doesn&#39;t need Git on their machine anyways?</p>
<h4>Install Grunt</h4>
<p>We&#39;ll use NPM to install Grunt CLI (Command-Line Interpreter) from the console:</p>
<pre><code>npm install -g grunt-cli</code></pre>
<p><strong>Note:</strong> The <code>-g</code> flag stands for <em>global</em>, which makes Grunt CLI available from any folder on your machine.</p>
<p>That&#39;s it! You&#39;re ready to add Grunt magic to your projects.</p>
<h4>Set up your first Grunt project</h4>
<p>Let&#39;s create a new project:</p>
<pre><code>mkdir my-project
cd my-project</code></pre>
<p>There are two main files you need to create in the root directory of your project:</p>
<ul>
<li><code>package.json</code>: this file is used to store NPM metadata such as the name and description of the project, and its dependencies;</li>
<li><code>Gruntfile.js</code>: this file is used to load and configure your grunt tasks.</li>
</ul>
<p>Your project&#39;s file structure should look like this:</p>
<pre><code>my-project/
    Gruntfile.js
    package.json</code></pre>
<h5>package.json</h5>
<p>Let&#39;s create a very basic version of this file:</p>
<pre><code>{
  &quot;name&quot;: &quot;my-project&quot;, // the name of our project, hyphen-separated
  &quot;version&quot;: &quot;0.0.0&quot; // project version (in semantic format)
}</code></pre>
<p>Now, let&#39;s install Grunt in our current project. But wait, didn&#39;t we do that already? Well, what we did install in the first part of the chapter was Grunt CLI, which is just a small utility that runs the local version of <code>grunt</code> for you. So, we still need to add Grunt locally (hence the lack of the <code>-g</code> flag):</p>
<pre><code>npm install grunt --save-dev</code></pre>
<p>The <code>--save-dev</code> flag instructs NPM to update <code>package.json</code> to include <code>grunt</code> as a dependency for the project. Our file will now look like this:</p>
<pre><code>{
  &quot;name&quot;: &quot;my-project&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,

  // the list of project dependencies
  &quot;devDependencies&quot;: {
      &quot;grunt&quot;: &quot;~0.4.1&quot;
  }
}</code></pre>
<p>In addition, you&#39;ll notice a <code>node_modules</code> directory added to your project. This is where all local NPM modules are installed &mdash; like we just did with <code>grunt</code> &mdash; and can be safely added to <code>.gitignore</code>.</p>
<p>Your project&#39;s file structure now looks like this:</p>
<pre><code>my-project/
    node_modules/
    Gruntfile.js
    package.json</code></pre>
<p><em>Did you know?</em> Running <code>npm install</code> in any project directory that has a <code>package.json</code> will install all its necessary dependencies with their appropriate versions, as listed in the <code>devDependencies</code> property.</p>
<h5>Gruntfile.js</h5>
<p>Next, let&#39;s create a Gruntfile next to our <code>package.json</code>. The basic format for the file is this:</p>
<pre><code>module.exports = function(grunt) {
  // We&#39;ll do grunt stuff here soon!
};</code></pre>
<p>For example, let&#39;s write a task that just prints out <code>Hello World!</code> into the console:</p>
<pre><code>module.exports = function(grunt) {
  grunt.registerTask(&#39;default&#39;, function() {
      grunt.log.write(&#39;Hello World!&#39;);
  });
};</code></pre>
<p>And now to run it:</p>
<pre><code>grunt
&gt; Running &quot;default&quot; task
&gt; Hello World!</code></pre>
<h4>Take five</h4>
<p>OK, let&#39;s recap what we&#39;ve just done:</p>
<ul>
<li>We installed Node and Node Package Manager, which allows us to run Grunt and to quickly install all the necessary Grunt plugins;</li>
<li>We installed Grunt CLI globally;</li>
<li>We created a new, empty project;</li>
<li>We added basic versions of <code>package.json</code> and <code>Gruntfile.js</code>;</li>
<li>We ran <code>grunt</code> for the first time!</li>
</ul>
<p>You can read more at: <a href="http://gruntjs.com/getting-started">http://gruntjs.com/getting-started</a></p>
<h2>Recipes</h2>
<p>It&#39;s time to make Grunt do some actual work for us. Through these recipes, we&#39;ll automate stuff like:</p>
<ul>
<li>Minifying and concatenating our CSS and JS files;</li>
<li>Starting a local web server;</li>
<li>Watching for changes on files and running tasks accordingly.</li>
</ul>
<p>In the process, we&#39;ll get familiar with some of the more popular Grunt plugins.</p>
<h3>Lint your JavaScript code</h3>
<p><strong>Plugins used:</strong> <a href="https://npmjs.org/package/grunt-contrib-jshint"><code>grunt-contrib-jshint</code></a>.</p>
<p>A JavaScript linter is a tool that looks for syntax errors, bad practices and style inconsistencies in your code.</p>
<h4>Install the JSHint plugin</h4>
<pre><code>npm install grunt-contrib-jshint --save-dev</code></pre>
<h4>Load JSHint tasks into our Gruntfile</h4>
<pre><code>module.exports = function(grunt) {
    grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);
};</code></pre>
<h4>Confige the JSHint task</h4>
<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        jshint: {
            all: [&#39;scripts/*.js&#39;]
        }
    });
    grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);
};</code></pre>
<p>We added a call to <code>initConfig</code> for the <code>jshint</code> task. In it, we defined a single <em>target</em> called <code>all</code>. We told JSHint to look at all files with a <code>.js</code> extension within the <code>scripts</code> folder.</p>
<p><strong>Note:</strong> Grunt tasks can have multiple configurations, named <em>targets</em>. This allows us to use different sets of options for the same task, depending on what we need. A common scenario is having a target for <em>development</em> and one for <em>distribution</em>.</p>
<p>In defining the list of JavaScript files to lint, we&#39;ve used a shorthand. This is the equivalent, more explicit version:</p>
<pre><code>jshint: {
    all: {
        files: [&#39;scripts/*.js&#39;]
    }
}</code></pre>
<h4>Run the JSHint task</h4>
<p>In your project directory, run:</p>
<pre><code>grunt jshint:all</code></pre>
<p>...to run the JSHint task with the <code>all</code> target. Or simply:</p>
<pre><code>grunt jshint</code></pre>
<p>This is because <code>grunt-contrib-jshint</code> (along with most other Grunt tasks) is a so-called <em>multitask</em>. </p>
<p><strong>Note:</strong> Multitasks invoked without an explicit target will run for all targets. </p>
<p>In the output, you should see a list of all problems the tool found in the specified JavaScript files. This is great, albeit not so readable. Let&#39;s configure JSHint to output to a file rather than in the console:</p>
<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        jshint: {
            options: {
                reporterOutput: &#39;jshint.log&#39;
            }
            all: {
                files: [&#39;scripts/*.js&#39;]
            }
        }
    });
    grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);
};</code></pre>
<p>That&#39;s much better. Now we have the list of errors in a handy file in our project called <code>jshint.log</code>. Brilliant.</p>
<p>Here we&#39;ve set <code>options</code> globally for <em>all targets</em>, but each individual target can have its own <code>options</code> property. Target-level options will override the task-level options. </p>
<h4>More JSHint options</h4>
<p>We&#39;ve just configured an output file to serve as an error log. Next, let&#39;s look at how to customize the kind of rules JSHint enforces. Armed with the <a href="http://www.jshint.com/docs/options/">full list of JSHint flags</a>, we can create a JSON file which we&#39;ll name <code>.jshintrc</code> into our root directory. It looks something like this:</p>
<pre><code>{
  &quot;curly&quot;: true,
  &quot;eqnull&quot;: true,
  &quot;eqeqeq&quot;: true,
  &quot;undef&quot;: true,
  &quot;globals&quot;: {
    &quot;jQuery&quot;: true
  }
}</code></pre>
<p>Now, let&#39;s tell JSHint to look at this file for the rules to enforce:</p>
<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        jshint: {
            options: {
                jshintrc: &#39;.jshintrc&#39;,
                reporterOutput: &#39;jshint.log&#39;
            }
            all: {
                files: [&#39;scripts/*.js&#39;]
            }
        }
    });
    grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);
};</code></pre>
<h4>Take five</h4>
<p>In this recipe, we&#39;ve:</p>
<ul>
<li>installed, configured and ran our first <em>real</em> Grunt task;</li>
<li>learned about targets and multitasks, both of which are wonderful things.</li>
</ul>
<p><strong>Extra credits:</strong> You can grab a very similar task <a href="https://npmjs.org/package/grunt-contrib-csslint"><code>grunt-contrib-csslint</code></a>, and make it lint the CSS files in your project.</p>
<h3>Sassy Sass</h3>
<p><strong>Plugins used:</strong> <a href="https://npmjs.org/package/grunt-contrib-sass"><code>grunt-contrib-sass</code></a>.</p>
<p><strong>Note:</strong> To make <code>grunt-contrib-sass</code> work, you also need to have Ruby and Sass installed. To check if you have ruby installed, type <code>ruby -v</code> in the console. When you&#39;ve confirmed you have Ruby installed, run <code>gem install sass</code> to install Sass.</p>
<h4>Install the Sass plugin</h4>
<pre><code>npm install -g grunt-contrib-sass --save-dev</code></pre>
<p>and then, in our Gruntfile:</p>
<pre><code>grunt.loadNpmTasks(&#39;grunt-contrib-sass&#39;);</code></pre>
<h4>Configure the <code>sass</code> task</h4>
<p>We&#39;ll create a single target called <code>all</code> for our task. We&#39;ll then define a list of source/destination pairs in the <code>files</code> property:</p>
<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        sass: {
            all: {
                files: {
                    &#39;css/main.css&#39;: &#39;scss/main.scss&#39;,
                    &#39;css/homepage.css&#39;: &#39;scss/homepage.scss&#39;
                }
            }
        }
    });
    grunt.loadNpmTasks(&#39;grunt-contrib-sass&#39;);
};</code></pre>
<p>If you&#39;ve read through the previous recipe, you&#39;ll recall that the <code>files</code> property accepted an array of comma-separated file paths. Turns out there are a host of ways to describe the files your tasks needs to operate on, but we&#39;ll talk about that later. For now, let&#39;s examine this form:</p>
<pre><code>files: {
    &#39;css/main.css&#39;: &#39;scss/main.scss&#39;,
    &#39;css/homepage.css&#39;: &#39;scss/homepage.scss&#39;
}</code></pre>
<p>We&#39;ve defined <code>files</code> as an object with key/value pairs correspond to <em>destination-file</em>/<em>source-file</em>. </p>
<h4>Run the <code>sass</code> ask</h4>
<p>Let&#39;s run our task to see how it works:</p>
<pre><code>grunt sass</code></pre>
<h3> </h3>
<p>This means that for each new Sass file that you add to your project, you&#39;ll need to edit your Gruntfile to include a new source/destination pair in your <code>sass</code> task. Not too sexy. </p>
<p>Let&#39;s fix that by <em>building the files object dynamically</em>:</p>
<pre><code>files: [{
    expand: true,
    cwd: &#39;scss/&#39;,
    src: [&#39;*.scss&#39;],
    dest: &#39;css/&#39;,
    ext: &#39;.css&#39;
}]</code></pre>
<p>Okay, take a deep breath! There&#39;s a lot going on in the few lines above. First, we&#39;ve moved back to <code>files</code> as an array, but instead of strings describing single paths, we now have objects describing source/destination mappings. How is it done? Let&#39;s look at each property:</p>
<ul>
<li><code>expand</code> is set to <code>true</code> so that we can use the properties below:</li>
<li><code>cwd</code> (current working directory) is the common path to all the source files; in our case, all <code>.scss</code> files are inside the <code>scss</code> folder (note the trailing slash character);</li>
<li><code>src</code> is an array of one or more patterns to match, relative to <code>cwd</code>;</li>
<li><code>dest</code> is the counterpart to <code>cwd</code> and describes the destination path prefix; in other words, this is the destination folder for all our generated CSS files;</li>
<li><code>ext</code> is the new extension for the destination files; in our case, we want all <code>.scss</code> files to become <code>.css</code> files.</li>
</ul>
<p>In plain words, the previous construct reads as: </p>
<blockquote>
<p>Run all files with the <code>.scss</code> extension from the <code>scss</code> folder through the <code>sass</code> task and place the resulting files in the <code>css</code> folder, each with their original names but with the <code>.css</code> extension instead of <code>.scss</code>.</p>
</blockquote>
<p>If you run <code>grunt sass</code> again, you&#39;ll notice that everything still works, but with the added benefit that we add/remove Sass files to your project and they&#39;ll be picked up by the sass task without having to update the Gruntfile each time.</p>
<h4>Take five</h4>
<p>In this recipe, we&#39;ve learned:</p>
<ul>
<li>to write multiple source/destination pairs for the files used by our task;</li>
<li>to define these pairs dynamically so we don&#39;t have to maintain them, one by one, for all eternity.</li>
</ul>
<h3>Pre-compile your Handlebars templates</h3>
<p><strong>Plugins used:</strong> <a href="https://npmjs.org/package/grunt-contrib-handlebars"><code>grunt-contrib-handlebars</code></a>.</p>
<p><a href="http://handlebarsjs.com/">Handlebars</a> is a popular template library which helps you build HTML fragments populated with data from an object. A template looks something like:</p>
<pre><code>&lt;div class=&quot;person&quot;&gt;
  &lt;h1&gt;{{name}}&lt;/h1&gt;
  &lt;p&gt;{{description}}&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>The portions between <code>{{</code> and <code>}}</code> are dynamic and are populated from the object you feed to the template. If you are not familiar with it, its homepage describes the library in more depth.</p>
<p>There are two basic ways to include Handlebars templates in your web application:</p>
<ol>
<li><p>Inline them as strings in JavaScript: </p>
<pre><code> var template = &quot;&lt;div class=&quot;person&quot;&gt;&lt;h1&gt;{{name}}&lt;/h1&gt;&lt;p&gt;{{description}}&lt;/p&gt;&lt;/div&gt;&quot;;</code></pre>
<p> This is bad because we&#39;re mixing JavaScript and HTML, and it&#39;s not too readable either.</p>
</li>
<li><p>Include them in the HTML inside <code>&lt;script&gt;</code> tags:</p>
<pre><code> &lt;script type=&#39;text/x-handlebars&#39; id=&#39;person-template&#39;&gt;
     &lt;div class=&quot;person&quot;&gt;
       &lt;h1&gt;{{name}}&lt;/h1&gt;
       &lt;p&gt;{{description}}&lt;/p&gt;
     &lt;/div&gt;
 &lt;/script&gt;</code></pre>
<p> This is somewhat better, but includes the extra step of querying the DOM for the script element and reading its content as a string (<code>element.innerHTML</code>). In addition, the HTML file containing all these templates can get quite large and unmaintainable.</p>
</li>
</ol>
<p>Both techniques, as described, only get you to the point where you have the content of the template as a string. From hereon, you need to perform two additional steps:</p>
<ol>
<li>First, compile the string into a template function;</li>
<li>Call the template function with a data object to get the HTML fragment.</li>
</ol>
<p>Let&#39;s see how <code>grunt-contrib-handlebars</code> can make this all better.</p>
<h4>The advantages of pre-compiling your templates</h4>
<p>Here&#39;s what&#39;s in it for you: </p>
<ul>
<li>You get to keep your templates in separate files, without the performance penalty of separate HTTP requests for each one;</li>
<li>You make your app faster by skipping the DOM queries and the compilation step;</li>
<li>You reduce the payload by including only the Handlebars Runtime library, which is smaller and faster, instead of the whole shebang.</li>
</ul>
<p>Sold? Right, let&#39;s get on with it.</p>
<h4>Install the <code>handlebars</code> task</h4>
<pre><code>npm install grunt-contrib-handlebars --save-dev</code></pre>
<p>and then add it to your Gruntfile:</p>
<pre><code>grunt.loadNpmTasks(&#39;grunt-contrib-handlebars&#39;);</code></pre>
<h4>Configuring the <code>handlebars</code> task</h4>
<p>In its most basic form, we only need to define the <em>source</em> and <em>destination</em> files:</p>
<pre><code>handlebars: {
    all: {
        files: {
            &quot;js/templates.js&quot;: [&quot;templates/**/*.hbs&quot;]
        }
    }
}</code></pre>
<p>Let&#39;s run this to see what happens:</p>
<pre><code>grunt handlebars</code></pre>
<p>Grunt will take all files with a <code>.hbs</code> extension from the <code>templates</code> folder and all its sub-folders and merge them into a single file called <code>templates.js</code>, which looks something like this:</p>
<p>[[ INSERT CODE EXAMPLE ]] </p>
<p>You can now include a single file in your HTML:</p>
<pre><code>&lt;script type=&#39;text/javascript&#39; src=&#39;js/templates.js&#39;&gt;&lt;/script&gt;</code></pre>
<p>and in your JavaScript code, you access the templates as follows:</p>
<pre><code>var personTemplate = JST[&#39;person&#39;]; // presto!</code></pre>
<h4>More customization</h4>
<p>In real life, you&#39;ll probably want to add the templates under your application&#39;s namespace &mdash; something like <code>MyApp.Templates</code> &mdash; instead of <code>JST</code>. This is done using the <code>namespace</code> option:</p>
<pre><code>handlebars: {
    options: {
        namespace: &#39;MyApp.Templates&#39;
    },
    all: {
        files: {
            &quot;js/templates.js&quot;: [&quot;templates/**/*.hbs&quot;]
        }
    }
}</code></pre>
<p>Let&#39;s also configure how template names are generated for each file, using the <code>processName</code> option. We define a function which takes one argument (the file path) and returns the string to use as the template name:</p>
<pre><code>options: {
    processName: function(filePath) {

        // split path at slash, hyphen and space
        var parts = filePath.split(/[\/\-\s]/); 

        // capitalize each part, starting from the second
        for (var i = 1; i &lt; parts.length; i++) {
            parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].substr(1);
        }

        // restore the string and return it
        return parts.join(&#39;&#39;);
    }
}</code></pre>
<p>In the example above, we&#39;re transforming the template path into a camel-case name:</p>
<pre><code>templates/product/detail.hbs -&gt; &#39;productDetail&#39;</code></pre>
<h4>Take five</h4>
<p>In this recipe, we made Handlebars templates better in terms of speed and maintainability. In fact, if you install Handlebars syntax highlighting in your favorite editor (I use Sublime Text), you&#39;ll get even more clarity by keeping your templates in separate <code>.hbs</code> files.</p>
<h3>Watch for changes</h3>
<p><strong>Plugins used:</strong> <a href="https://npmjs.org/package/grunt-contrib-watch"><code>grunt-contrib-watch</code></a>.</p>
<p>In the previous recipes, we saw how we can compile our Sass files into CSS files and merge your Handlebars templates into a single JST file. It is somewhat magical, but to run <code>grunt sass</code> after every change is far from being productive. Let&#39;s take this up a notch and make our files recompile automatically every time they change. For this, we will use the <code>watch</code> task provided by <code>grunt-contrib-watch</code>. </p>
<p>As usual, let&#39;s install it in our project:</p>
<pre><code>npm install grunt-contrib-watch</code></pre>
<p>and load the tasks in our Gruntfile, next to our Sass task:</p>
<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        sass: {
            all: {
                files: {
                    &#39;main.css&#39;: &#39;main.scss&#39;,
                    &#39;homepage.css&#39;: &#39;homepage.scss&#39;
                }
            }
        }
    });
    grunt.loadNpmTasks(&#39;grunt-contrib-sass&#39;);
    grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);
};</code></pre>
<h4>Configuring the <code>watch</code> task</h4>
<p>There are really only two things to define:</p>
<ul>
<li>which files we need to watch;</li>
<li>what task(s) to run when the files change.</li>
</ul>
<p>So let&#39;s go ahead and do that:</p>
<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        sass: {
            all: {
                files: {
                    &#39;css/main.css&#39;: &#39;scss/main.scss&#39;,
                    &#39;css/homepage.css&#39;: &#39;scss/homepage.scss&#39;
                }
            }
        },

        watch: {
            sass: {
                files: [&#39;scss/**/*.scss&#39;],
                tasks: [&#39;sass&#39;]
            },
            handlebars: {
                files: [&#39;templates/**/*.hbs&#39;],
                tasks: [&#39;handlebars&#39;]
            }
        }
    });
    grunt.loadNpmTasks(&#39;grunt-contrib-sass&#39;);
    grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);
};</code></pre>
<p>We&#39;ve created two targets for our <code>watch</code> task, one for watching the Sass files and one for watching the Handlebars templates. In both instances, we&#39;ve used <em>wildcards</em> to define patterns to match the desired files. In effect, the <code>scss/**/*.scss</code> pattern is similar to <code>scss/*.scss</code> (i.e. match all files with the <code>.scss</code> extension within the <code>scss</code> folder) with the exception that the former looks into subfolders as well. When any of the files change, the associated task is executed. </p>
<p>Let&#39;s check it out in action:</p>
<pre><code>grunt watch</code></pre>
<p>Because <code>watch</code> is a <em>multitask</em>, what we&#39;re actually saying with the above command is:</p>
<pre><code>grunt watch:sass watch:handlebars</code></pre>
<p>Now go ahead and change one of your Sass files, and notice that the <code>sass</code> task is run. At the same time, if a Handlebars template changes, the <code>handlebars</code> task is run.</p>
<h4>Tweaking the watch behavior</h4>
<p>By default, <code>watch</code> looks for three kinds of changes: </p>
<ul>
<li>files that were <em>added</em> to the project and match the pattern;</li>
<li>matching files files that were <em>deleted</em>;</li>
<li>matching files that were <em>changed</em>. </li>
</ul>
<p>This behavior is controlled by the <code>events</code> option, which can have one or many of the values: <code>all</code> (the default), <code>changed</code>, <code>added</code> and <code>deleted</code>. Let&#39;s assume we want to run the <code>handlebars</code> task only when a template is added or deleted &mdash; an no, it doesn&#39;t make sense in a real-world scenario, but go with me:</p>
<pre><code>watch: {
    handlebars: {
        files: [&#39;templates/**/*.hbs&#39;],
        tasks: [&#39;handlebars&#39;],
        options: {
            events: [&#39;added&#39;, &#39;deleted&#39;]
        }
    }
}</code></pre>
<p>This will make the watch ignore changes in existing Handlebars templates and only react when we add or remove Handlebars templates.</p>
<p>Alrighty then.</p>
<p>There&#39;s one little quirk we need to address: the <code>watch</code> task will only pick up on changes that happen <em>after</em> we call <code>grunt task</code>. We&#39;d like to make sure our generated CSS and compiled templates are up-to-date when the watch starts. For this, we will use <code>atBegin: true</code> to run <em>all tasks</em> associated with the watch before the actual watching begins. Because we want this behavior for both Sass and Handlebars files, we will add this option on the task directly rather than on each target:</p>
<pre><code>watch: {
    options: {
        atBegin: true
    },
    sass: {
        files: [&#39;scss/**/*.scss&#39;],
        tasks: [&#39;sass&#39;]
    },
    handlebars: {
        files: [&#39;templates/**/*.hbs&#39;],
        tasks: [&#39;handlebars&#39;]
    }
}</code></pre>
<h4>Take five</h4>
<p>In this recipe, we&#39;ve:</p>
<ul>
<li>learned how to use <code>watch</code> to trigger other tasks automatically when you make changes to your files;</li>
<li>configured the types of events the watch responds to;</li>
<li>run the associated tasks at the beginning of the watch process to make sure everything is up to date.</li>
</ul>
<h3>Start a server</h3>
<p><strong>Using:</strong> <a href="https://npmjs.org/package/grunt-contrib-connect"><code>grunt-contrib-connect</code></a></p>
<h4>Install the <code>connect</code> task</h4>
<pre><code>npm install grunt-contrib-connect --save-dev</code></pre>
<p>and then load it into  your Gruntfile:</p>
<pre><code>grunt.loadNpmTasks(&#39;grunt-contrib-connect&#39;);</code></pre>
<h4>Configure a persistent server</h4>
<p>To create a persistent server (one which does not stop after Grunt tasks have completed), we will use <code>keepalive: true</code>:</p>
<pre><code>connect: {
    server: {
        options: {
            keepalive: true
        }
    }
}</code></pre>
<p>We&#39;ve created a single target called <code>server</code> for our <code>connect</code> task.</p>
<h4>Run your server</h4>
<pre><code>grunt connect:server</code></pre>
<p>Now go to <a href="http://localhost:8000">http://localhost:8000</a> and you should be able to browse your app, and see your <code>index.html</code> if you have one.</p>
<h4>More server configuration</h4>
<p>You can customize the host name, port and protocol for your server:</p>
<pre><code>connect: {
    server: {
        options: {
            keepalive: true,
            protocol: &#39;https&#39;,
            hostname: &#39;myapp&#39;,
            port: &#39;8080&#39;
        }
    }
}</code></pre>
<p>The code above makes the server available at <a href="https://myapp:8080">https://myapp:8080</a>. This is useful in the case you want to start several servers at once, with different base directories, as in the example below:</p>
<pre><code>connect: {
    first: {
        options: {
            keepalive: true,
            hostname: &#39;firstsite&#39;,
            base: &#39;first-site&#39;
        }
    },
    second: {
        options: {
            keepalive: true,
            hostname: &#39;secondsite&#39;,
            base: &#39;second-site&#39;
        }
    }
}</code></pre>
<p>This makes the directories <code>first-site</code> and <code>second-site</code> from your project available at <a href="http://firstite:8000">http://firstite:8000</a> and <a href="http://secondsite:8000">http://secondsite:8000</a>, respectively.</p>
<h4>Take five</h4>
<p>In this recipe, we&#39;ve learned how to use the <code>connect</code> task to start a local server.</p>
<h3>Build an app for deployment</h3>
<p>By now, you should be comfortable with working with one task at a time. It&#39;s time to really make Grunt shine by integrating the variety of tasks involved in preparing a web application for deployment, such as precompiling, minifying, concatenating and moving files around.</p>
<h4>What we&#39;re trying to accomplish</h4>
<p>We want to take our main HTML file, identify all the stylesheets and scripts it references, optimize those (e.g. minification, concatenation) and then update the references from the HTML with the optimized version.</p>
<p>At the end of the task, we want to have a <code>dist</code> folder that contains the optimized version of our project, readily deployable to a production environment.</p>
<h4>Tasks we&#39;ll use in this recipe</h4>
<ul>
<li><a href="https://npmjs.org/package/grunt-contrib-uglify"><code>grunt-contrib-uglify</code></a> to minify JavaScript;</li>
<li><a href="https://npmjs.org/package/grunt-contrib-cssmin"><code>grunt-contrib-cssmin</code></a> to minify CSS;</li>
<li><a href="https://npmjs.org/package/grunt-contrib-htmlmin"><code>grunt-contrib-htmlmin</code></a> to minify gruntde;</li>
<li><a href="https://npmjs.org/package/grunt-contrib-concat"><code>HTML-contrib-concat</code></a> to concatenate files;</li>
<li><a href="https://npmjs.org/package/grunt-contrib-copy"><code>grunt-contrib-copy</code></a> to copy files and folders;</li>
<li><a href="https://github.com/yeoman/grunt-usemin"><code>grunt-usemin</code></a> to replaces references to scripts and stylesheets in HTML files with their optimized versions.</li>
</ul>
<p>Now, don&#39;t get too intimidated! If you think about it each task has a very specific purpose in the workflow, and you&#39;ll see how easy is to choreograph them into one fluent, beautiful task.</p>
<h4>Let&#39;s install everything</h4>
<pre><code>npm install grunt-contrib-uglify grunt-contrib-concat grunt-contrib-cssmin grunt-contrib-htmlmin grunt-contrib-copy grunt-usemin --save-dev</code></pre>
<p>... in one fell swoop, even. Now let&#39;s add all of it to our Gruntfile:</p>
<pre><code>grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);
grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);
grunt.loadNpmTasks(&#39;grunt-contrib-cssmin&#39;);
grunt.loadNpmTasks(&#39;grunt-contrib-htmlmin&#39;);
grunt.loadNpmTasks(&#39;grunt-contrib-copy&#39;);
grunt.loadNpmTasks(&#39;grunt-usemin&#39;);</code></pre>
<h4>Basic configuration</h4>
<pre><code>grunt.initConfig({

    // Minimize tasks
    cssmin: {
        all: {
            files: {
                &#39;dist/css/app.css&#39;: &#39;app/css/**/*.css&#39;
            }
        }
    },

    htmlmin: {
        all: {
            files: [{
                expand: true,
                cwd: &#39;app/&#39;,
                src: &#39;**/*.html&#39;,
                dest: &#39;dist/&#39;
            }]
        }
    },

    // Move other things around
    copy: {
        all: {
            files: [{
                expand: true,
                cwd: &#39;app/&#39;,
                dest: &#39;dist/&#39;,
                src: [
                    &#39;.htaccess&#39;,
                    &#39;*.ico&#39;,
                    &#39;images/**/*.{jpg,png,gif}&#39;,
                    &#39;css/fonts/*&#39;
                ]        
            }]
        }
    }

});</code></pre>
<p>Let&#39;s take the code above apart, piece by piece.</p>
<p>First, we configure the <code>cssmin</code> task to take all stylesheets from <code>app/css</code> and minimize and concatenate them in a single file in <code>dist/css</code> called <code>app.css</code>.
We do the same for HTML, except we&#39;re using a dynamic declaration of the files object since we want to have a separate HTML file in the <code>dist</code> folder for each HTML in our <code>app</code> folder.</p>
<p>Then we configure the <code>copy</code> task to copy into the <code>dist</code> folder one by one any files not already covered by the other tasks &mdash; stuff like icons, images, fonts, etc.  </p>
<p>We already notice we&#39;ve been using <code>app</code> and <code>dist</code> a lot, so let me take this moment to introduce a handy way to Not Repeat Yourself: enter <strong>Grunt templates</strong>. They are tiny dynamic snippets delimited by <code>&lt;%</code> and <code>%&gt;</code> that you can add to your strings. We&#39;re interested in templates of the form <code>&lt;%= object.property.path %&gt;</code> which expands to the corresponding value from Grunt&#39;s configuration object. Let&#39;s see it in action:</p>
<pre><code>grunt.initConfig({

    appConfig: {
        appRoot: &#39;app&#39;,
        distRoot: &#39;dist&#39;
    },

    // Minimize tasks
    cssmin: {
        all: {
            files: {
                &#39;&lt;%= appConfig.distRoot %&gt;/css/app.css&#39;: &#39;&lt;%= appConfig.appRoot %&gt;/css/**/*.css&#39;
            }
        }
    },

    htmlmin: {
        all: {
            files: [{
                expand: true,
                cwd: &#39;&lt;%= appConfig.appRoot %&gt;/&#39;,
                src: &#39;**/*.html&#39;,
                dest: &#39;&lt;%= appConfig.distRoot %&gt;&#39;
            }]
        }
    },

    // Move other things around
    copy: {
        all: {
            files: [{
                expand: true,
                cwd: &#39;&lt;%= appConfig.appRoot %&gt;/&#39;,
                dest: &#39;&lt;%= appConfig.distRoot %&gt;&#39;,
                src: [
                    &#39;.htaccess&#39;,
                    &#39;*.ico&#39;,
                    &#39;images/**/*.{jpg,png,gif}&#39;,
                    &#39;css/fonts/*&#39;
                ]        
            }]
        }
    }

});</code></pre>
<p>We&#39;ve defined an <code>appConfig</code> property to hold our commonly-used paths. Now we can refer to the two paths as <code>&lt;%= appConfig.appRoot %&gt;</code> and <code>&lt;%= appConfig.distRoot %&gt;</code> in all our tasks.</p>
<p><strong>Note:</strong> You can define any number of custom properties in your Grunt configuration (like we did above with <code>appConfig</code>), but make sure the names don&#39;t conflict with any task names and stay away from the <code>grunt</code> keyword, which is reserved to access the Grunt object in the templates.</p>
<p>Another cool thing we can do is to get a timestamp for the current Grunt run and add that to the generated CSS/JS files to ensure they are unique.</p>
<pre><code>{
    appConfig: {
        appRoot: &#39;app&#39;,
        distRoot: &#39;dist&#39;,
        timestamp: Date.now()
    }
}</code></pre>
<p>And here&#39;s how we might use this to append the timestamp to our generated CSS file in <code>cssmin</code>:</p>
<pre><code>cssmin: {
    all: {
        files: {
            &#39;&lt;%= appConfig.distRoot %&gt;/css/app.&lt;%= appConfig.timestamp %&gt;.css&#39;: &#39;&lt;%= appConfig.appRoot %&gt;/css/**/*.css&#39;
        }
    }
}</code></pre>
<h3>Loading external data in our tasks</h3>
<p>Grunt provides two methods for loading external data into the Gruntfile:</p>
<ul>
<li><code>grunt.file.readJSON()</code> to load an external JSON file;</li>
<li><code>grunt.file.readYAML()</code> to load an external YAML file;</li>
</ul>
<p>Let&#39;s use <code>readJSON()</code> for something fun like automatically loading all the tasks defined in <code>package.json</code>:</p>
<pre><code>module.exports = function(grunt) {

    // load `package.json`
    var package = grunt.file.readJSON(&#39;package.json&#39;);

    // check if we have any dependencies
    if (package.devDependencies) {

        // filter out the ones that don&#39;t start with `grunt-`
        var gruntTasks = Object.keys(package.devDependencies).filter(function(task) {
            return task.indexOf(&#39;grunt-&#39;) === 0;    
        });

        // load each task
        gruntTasks.forEach(grunt.loadNpmTasks);
    }
};</code></pre>
<p><strong>Note:</strong> <code>readJSON()</code> only accepts <em>valid</em> JSON-files, while <code>package.json</code> can be JSON-like and still work with <code>npm install</code>. The most common JSON-like-but-not-quite-JSON thing it might contain are comments, which work perfectly fine with the NPM installer but will break the above script.</p>
<h3>Files, in-depth</h3>
<p><a href="http://gruntjs.com/configuring-tasks#files">http://gruntjs.com/configuring-tasks#files</a></p>
<h3>Using variables/templates</h3>
<h2>Write your own Grunt plugin</h2>

		</article>
	</body>
</html>
